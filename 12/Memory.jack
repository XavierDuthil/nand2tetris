// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * Memory operations library.
 */ 
class Memory {
    static Array memory;
    static int freeOffset;
    static FreeList freeListHead;

    /** Initializes memory parameters. */
    function void init() {
        let freeListHead = new FreeList();
        let freeListHead.offset = 2048;
        let freeListHead.length = 16384 - 2048; // HeapBottom - HeapStart
        let freeListHead.next = null;

        let memory = 0;
        return;
    }

    /** Returns the value of the main memory at the given address. */
    function int peek(int address) {
        return memory[address];
    }

    /** Sets the value of the main memory at this address
     *  to the given value. */
    function void poke(int address, int value) {
         let memory[address] = value;
         return;
    }

    /** finds and allocates from the heap a memory block of the 
     *  specified size and returns a reference to its base address. */
    function int alloc(int size) {
        var FreeList bestFreeList;
        let bestFreeList = freeListHead;

        // Segment has two parts: a:the length of the segment and b:the allocated space requested
        var int segmentSize;
        let segmentSize = size + 1; // Need to use the first offset for storing the size

        // Search the first fitting freeList
        while (segmentSize > bestFreeList.length){
            let bestFreeList = bestFreeList.next;

            if (bestFreeList = null){
                return -1;
            }
        }

        var int offset;
        let offset = bestFreeList.offset;
        let memory[offset] = segmentSize;

        // Update the chosen freeList object
        let bestFreeList.offset = offset + segmentSize;
        let bestFreeList.length = bestFreeList.length - segmentSize;

        return offset + 1;
    }

    /** De-allocates the given object and frees its space. */
    function void deAlloc(int deAlloc) {
        var int segmentOffset;
        let segmentOffset = deAlloc - 1;

        var int segmentSize;
        let segmentSize = memory[segmentOffset];

        var int followingOffset;
        let followingOffset = segmentOffset + segmentSize;

        var FreeList previousFreeList;
        let previousFreeList = null;

        var FreeList followingFreeList;
        let followingFreeList = freeListHead;

        // Search the closest previous freeList
        while (~(followingFreeList = null) & (followingFreeList.offset < deAlloc)){
            let previousFreeList = followingFreeList;
            let followingFreeList = followingFreeList.next;
        }

        var FreeList newFreeList;
        let newFreeList = new FreeList();

        // Before freeListHead
        if (previousFreeList = null) {
            // Insert new freeList
            let newFreeList.offset = segmentOffset;
            let newFreeList.length = segmentSize;
            let newFreeList.next = freeListHead;

            let freeListHead = newFreeList;
        }

        else {
            // Insert new freeList
            let newFreeList.offset = segmentOffset;
            let newFreeList.length = segmentSize;
            let newFreeList.next = followingFreeList;

            let previousFreeList.next = newFreeList;
        }
        
        // Can merge
        if (~(followingFreeList = null) & (followingOffset = followingFreeList.offset)) {
            let newFreeList.next = followingFreeList.next;
            let newFreeList.length = newFreeList.length + followingFreeList.next;
            let followingFreeList = null;
        }
    }
}

class FreeList {
    var int offset;
    var int length;
    var FreeList next;
}