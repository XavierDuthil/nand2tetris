// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Screen.jack

/**
 * Graphic screen library.
 */
class Screen {
    static int SCREEN_STARTING_ADDRESS;
    static int PIXELS_PER_WORD;
    static int WORDS_PER_LINE;
    static int currentCursorAddress;

    /** Initializes the Screen. */
    function void init() {
        let SCREEN_STARTING_ADDRESS = 16384;
        let PIXELS_PER_WORD = 16;
        let WORDS_PER_LINE = 32;

        let currentCursorAddress = 16384;
        return;
    }

    /** Erases the whole screen. */
    function void clearScreen() {
        return;
    }

    /** Sets the color to be used in further draw commands
     *  where white = false, black = true. */
    function void setColor(boolean b) {
        return;
    }

    /** Draws the (x, y) pixel. */
    function void drawPixel(int x, int y) {
        var int memoryAddress, verticalOffset, horizontalOffset, remainder, value;

        let verticalOffset = y * WORDS_PER_LINE;
        let horizontalOffset = x / PIXELS_PER_WORD;
        let remainder = x - (horizontalOffset * PIXELS_PER_WORD);
        let memoryAddress = SCREEN_STARTING_ADDRESS + verticalOffset + horizontalOffset;

        let value = Memory.peek(memoryAddress) | Screen.pow(2, remainder);
        do Memory.poke(memoryAddress, value);
        return;
    }

    /** Draws a line from (initialX, initialY) to (finalX, finalY). */
    function void drawLine(int initialX, int initialY, int finalX, int finalY) {
        var int step, slope, currentX, currentY, tryX, tryY, bestX, bestY, tryDistance, bestDistance, deviation, horizontalDistanceCovered, verticalDistanceCovered, dx, dy;

        let currentX = initialX;
        let currentY = initialY;

        if (initialX > finalX) {
            do Screen.drawLine(finalX, finalY, initialX, initialY);
            return;
        }

        // Case: Horizontal line
        if (initialY = finalY) {
            while (currentX < finalX) {
                do Screen.drawPixel(currentX, currentY);
                let currentX = currentX + 1;
            }
            return;
        }

        // Case: Vertical line
        if (initialX = finalX) {
            if (currentY < finalY) {
                while (currentY < finalY) {
                    do Screen.drawPixel(currentX, currentY);
                    let currentY = currentY + 1;
                }
            }
            else {
                while (currentY > finalY) {
                    do Screen.drawPixel(currentX, currentY);
                    let currentY = currentY - 1;
                }
            }
            return;
        }

        let dx = finalX - initialX;
        let dy = finalY - initialY;

        //draw diagonal line 
        let deviation = 0;

        if(initialY < finalY){

            let horizontalDistanceCovered = 0;
            let verticalDistanceCovered = 0;

            //x++,y++
            while(~(horizontalDistanceCovered > dx) & ~(verticalDistanceCovered > dy)){
                
                do Screen.drawPixel(initialX + horizontalDistanceCovered, initialY + verticalDistanceCovered);
                
                if(deviation > 0){
                    let horizontalDistanceCovered = horizontalDistanceCovered + 1;
                    let deviation = deviation - dx;
                }else{
                    let verticalDistanceCovered = verticalDistanceCovered + 1;
                    let deviation = deviation + dy;
                }

            }
        }
        return;


        /*do Screen.drawPixel(currentX, currentY);

        while(~(currentX = finalX) | ~(currentY = finalY)) {
            // Try up
            let tryX = currentX;
            let tryY = currentY - 1;

            let bestDistance = Math.abs(finalX - tryX) + Math.abs(finalY - tryY);
            // do Output.printInt(bestDistance);
            // do Output.printString(" ");
            let bestX = tryX;
            let bestY = tryY;

            // Try down
            let tryX = currentX;
            let tryY = currentY + 1;

            let tryDistance = Math.abs(finalX - tryX) + Math.abs(finalY - tryY);
            // do Output.printInt(tryDistance);
            // do Output.printString(" ");
            if (tryDistance < bestDistance) {
                let bestDistance = tryDistance;
                let bestX = tryX;
                let bestY = tryY;
            }

            // Try right
            let tryX = currentX + 1;
            let tryY = currentY;

            let tryDistance = Math.abs(finalX - tryX) + Math.abs(finalY - tryY);
            // do Output.printInt(tryDistance);
            // do Output.printString(" ");
            if (tryDistance < bestDistance) {
                let bestDistance = tryDistance;
                let bestX = tryX;
                let bestY = tryY;
            }

            // Try left
            let tryX = currentX - 1;
            let tryY = currentY;

            let tryDistance = Math.abs(finalX - tryX) + Math.abs(finalY - tryY);
            // do Output.printInt(tryDistance);
            // do Output.printString(" ");
            if (tryDistance < bestDistance) {
                let bestDistance = tryDistance;
                let bestX = tryX;
                let bestY = tryY;
            }

            do Screen.drawPixel(bestX, bestY);
            let currentX = bestX;
            let currentY = bestY;
            // do Output.println();
        }
        return;*/
    }

    /** Draws a filled rectangle where the top left corner
     *  is (initialX, initialY) and the bottom right corner is (finalX, finalY). */
    function void drawRectangle(int initialX, int initialY, int finalX, int finalY) {
        return;
    }

    /** Draws a filled circle of radius r around (cx, cy). */
    function void drawCircle(int cx, int cy, int r) {
        return;
    }

    function int modulo(int value, int mod) {
        return value - ((value / mod) * mod);
    }

    function int pow(int base, int exponent) {
        var int result;
        let result = 1;

        while (exponent > 0) {
            let result = result * base;  
            let exponent = exponent - 1;
        }
        return result;
    }

    function int round(double value) {
        var int sign, result, intValue;

        do Output.printInt(value);

        if (value > 0.0 | value = 0.0) {
            let sign = 1;
        } else {
            let sign = -1;
        }

        let intValue = value;  // Convert double to int ? Doesn't seem to work

        do Output.printInt(intValue);
        do Output.printInt(sign);

        if (value > 0.0 | value = 0.0) {
            if ((value - intValue) * sign < 0.5) { 
                return intValue * sign;
            }
        }

        // Add 1 to abs and re-apply sign
        return ((intValue * sign) + 1) * sign;
    }
}
