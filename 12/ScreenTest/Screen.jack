// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Screen.jack

/**
 * Graphic screen library.
 */
class Screen {
    static int SCREEN_STARTING_ADDRESS;
    static int PIXELS_PER_WORD;
    static int WORDS_PER_LINE;
    static int currentCursorAddress;

    /** Initializes the Screen. */
    function void init() {
        let SCREEN_STARTING_ADDRESS = 16384;
        let PIXELS_PER_WORD = 16;
        let WORDS_PER_LINE = 32;

        let currentCursorAddress = 16384;
        return;
    }

    /** Erases the whole screen. */
    function void clearScreen() {
        return;
    }

    /** Sets the color to be used in further draw commands
     *  where white = false, black = true. */
    function void setColor(boolean b) {
        return;
    }

    /** Draws the (x, y) pixel. */
    function void drawPixel(int x, int y) {
        var int memoryAddress, verticalOffset, horizontalOffset, remainder, value;

        let verticalOffset = y * WORDS_PER_LINE;
        let horizontalOffset = x / PIXELS_PER_WORD;
        let remainder = x - (horizontalOffset * PIXELS_PER_WORD);
        let memoryAddress = SCREEN_STARTING_ADDRESS + verticalOffset + horizontalOffset;

        let value = Memory.peek(memoryAddress) | Screen.pow(2, remainder);
        do Memory.poke(memoryAddress, value);
        return;
    }

    /** Draws a line from (initialX, initialY) to (finalX, finalY). */
    function void drawLine(int initialX, int initialY, int finalX, int finalY) {
        var int step, slope, currentX, currentY, tryX, tryY, bestX, bestY, tryDistance, bestDistance, deviation, horizontalDistanceCovered, verticalDistanceCovered, dx, dy;

        let currentX = initialX;
        let currentY = initialY;

        if (initialX > finalX) {
            do Screen.drawLine(finalX, finalY, initialX, initialY);
            return;
        }

        // Case: Horizontal line
        if (initialY = finalY) {
            while (currentX < finalX) {
                do Screen.drawPixel(currentX, currentY);
                let currentX = currentX + 1;
            }
            return;
        }

        // Case: Vertical line
        if (initialX = finalX) {
            if (currentY < finalY) {
                while (currentY < finalY) {
                    do Screen.drawPixel(currentX, currentY);
                    let currentY = currentY + 1;
                }
            }
            else {
                while (currentY > finalY) {
                    do Screen.drawPixel(currentX, currentY);
                    let currentY = currentY - 1;
                }
            }
            return;
        }

        let dx = finalX - initialX;
        let dy = finalY - initialY;

        //draw diagonal line 
        let deviation = 0;
        if (initialY < finalY) {
            let horizontalDistanceCovered = 0;
            let verticalDistanceCovered = 0;

            // x++, y++
            while(horizontalDistanceCovered < dx | verticalDistanceCovered < dy){
                do Screen.drawPixel(initialX + horizontalDistanceCovered, initialY + verticalDistanceCovered);
                
                if (deviation > 0) {
                    let horizontalDistanceCovered = horizontalDistanceCovered + 1;
                    let deviation = deviation - dy;
                } else {
                    let verticalDistanceCovered = verticalDistanceCovered + 1;
                    let deviation = deviation + dx;
                }
            }
        }

        else {
            let dy = -dy;

            let horizontalDistanceCovered = 0;
            let verticalDistanceCovered = 0;

            // x++, y--
            while (horizontalDistanceCovered < dx | verticalDistanceCovered < dy){
                do Screen.drawPixel(initialX + horizontalDistanceCovered, initialY - verticalDistanceCovered);
                
                if (deviation < 0) {
                    let horizontalDistanceCovered = horizontalDistanceCovered + 1;
                    let deviation = deviation + dy;
                } else {
                    let verticalDistanceCovered = verticalDistanceCovered + 1;
                    let deviation = deviation - dx;
                }
            }
        }
        return;
    }

    /** Draws a filled rectangle where the top left corner
     *  is (initialX, initialY) and the bottom right corner is (finalX, finalY). */
    function void drawRectangle(int initialX, int initialY, int finalX, int finalY) {
        return;
    }

    /** Draws a filled circle of radius r around (cx, cy). */
    function void drawCircle(int cx, int cy, int r) {
        return;
    }

    function int modulo(int value, int mod) {
        return value - ((value / mod) * mod);
    }

    function int pow(int base, int exponent) {
        var int result;
        let result = 1;

        while (exponent > 0) {
            let result = result * base;  
            let exponent = exponent - 1;
        }
        return result;
    }

    function int round(double value) {
        var int sign, result, intValue;

        do Output.printInt(value);

        if (value > 0.0 | value = 0.0) {
            let sign = 1;
        } else {
            let sign = -1;
        }

        let intValue = value;  // Convert double to int ? Doesn't seem to work

        do Output.printInt(intValue);
        do Output.printInt(sign);

        if (value > 0.0 | value = 0.0) {
            if ((value - intValue) * sign < 0.5) { 
                return intValue * sign;
            }
        }

        // Add 1 to abs and re-apply sign
        return ((intValue * sign) + 1) * sign;
    }
}
